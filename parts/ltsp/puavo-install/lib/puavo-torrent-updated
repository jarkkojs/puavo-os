#!/usr/bin/ruby

require 'fcntl'
require 'open3'
require 'socket'
require 'syslog'

Target_dir = '/images/rdiffs'
Urlbase = 'https://cdn.opinsys.net'     # XXX this might be something different

class Aria
  attr_reader :filename, :stdout, :wait_thr

  def initialize(filename)
    @filename = filename

    @outmsg = ''
    @errmsg = ''

    start_download
  end

  def start_download
    url = "#{ Urlbase }/#{ @filename }"

    torrent_filename = "#{ @filename }.torrent"
    filename_fp = "#{ Target_dir }/#{ @filename }"
    tmpfile = "#{ filename_fp }.tmp"

    # XXX we should maybe use rate limit from puavo-conf ?

    aria_args = [ '/usr/bin/env',
                  'LANG=C',
                  'aria2c',
                  '--bt-enable-lpd=true',
                  '--bt-stop-timeout=300',
                  '--ca-certificate=/etc/puavo-conf/rootca.pem',
                  '--check-integrity=true',
                  '--enable-color=false',
                  '--human-readable=false',
                  '--no-conf=true',
                  '--file-allocation=none',               # XXX is this good?
                  '--follow-torrent=mem',
                  "--index-out=1=#{ tmpfile }",
                  '--max-overall-download-limit=10M',     # XXX use rate limit
                  '--max-overall-upload-limit=10M',       # XXX use rate limit
                  '--seed-ratio=0.0',
                  '--summary-interval=1',
                  url ]

    # XXX we probably need --on-download-complete= as well so that we know
    # XXX when we can proceed (rename file and such)

    Syslog.log(Syslog::LOG_NOTICE,
               'starting aria2c with args %s', aria_args.join(' '))

    stdin, @stdout, stderr, @wait_thr \
      = Open3.popen3(*aria_args, :err => '/dev/null', :in  => '/dev/null')
  end

  def read_stdout
    begin
      @outmsg += @stdout.read_nonblock(1024)
    rescue EOFError, IOError
      Syslog.log(Syslog::LOG_NOTICE,
                 'we got stdout messages from aria2: %s', @outmsg)
      @stdout.close
      @stdout = nil
    end
  end

  def get_progress
    # XXX we can remove old messages from the queue, no need to go through
    # XXX the old ones...

    progress = nil
    @outmsg.split("\n").each do |line|
      fields = line.split
      next unless fields[1] && fields[5] && fields[5].match(/^ETA/)

      match = fields[1].match(/\((\d+)%\)$/)
      if match then
        progress = match[1]
      end
    end

    progress
  end

  def stop
    if @wait_thr.alive? then
      Process.kill('TERM', @wait_thr.pid)
    end

    @stdout.close if @stdout
    @stdout = nil
  end
end

class Server
  def initialize(server_socket)
    @server_socket = server_socket

    @client_socket = nil
    @filename_to_download = nil
    @read_filename = false

    @aria = nil

    @current_progress = nil
    @write_progress   = false
  end

  def loop
    readable = [ @server_socket ]
    writeable = []

    if @client_socket then
      readable  << @client_socket if @read_filename
      writeable << @client_socket if @write_progress
    end

    if @aria then
      readable << @aria.stdout if @aria.stdout
    end

    ios = IO.select(readable, writeable)

    if ios[0].include?(@server_socket) then
      Syslog.log(Syslog::LOG_INFO, 'new client connection')
      if @client_socket then
        Syslog.log(Syslog::LOG_INFO, 'breaking old client connection')
        @client_socket.close()
        @client_socket = nil
      end

      @client_socket, client_addr = @server_socket.accept_nonblock
      @filename_to_download = ''
      @read_filename = true

      # @client_socket has been switched, must return
      return
    end

    if ios[1].include?(@client_socket) then
      Syslog.log(Syslog::LOG_INFO, 'writing progress to client')
      @client_socket.write_nonblock("#{ @current_progress }\n")
      @write_progress = false
    end

    if ios[0].include?(@client_socket) then
      begin
        @filename_to_download += @client_socket.read_nonblock(1024)
      rescue EOFError
        @filename_to_download.chomp!
        Syslog.log(Syslog::LOG_NOTICE,
                   "client asks to download '%s'",
                   @filename_to_download)
        @client_socket.shutdown(:RD)
        @read_filename = false

        @current_progress = nil

        if @aria && @aria.filename != @filename_to_download then
          @aria.stop
          @aria = nil
        end
        if !@aria then
          @aria = Aria.new(@filename_to_download)
        end
      end
    end

    if @aria then
      @aria.read_stdout if @aria.stdout && ios[0].include?(@aria.stdout)

      new_progress = @aria.get_progress
      if new_progress != @current_progress then
        @current_progress = new_progress
        @write_progress = true
        Syslog.log(Syslog::LOG_INFO, 'progress is now %s', @current_progress)
      end

      if @aria.wait_thr && !@aria.stdout then
        status = @aria.wait_thr.value
        Syslog.log(Syslog::LOG_NOTICE, 'we got exit code from aria: %s',
                                       status.exitstatus)
        @aria = nil
        @client_socket.write_nonblock(status.success? ? "OK\n" : "FAIL\n")
        @client_socket.close
      end
    end
  end
end

Syslog.open( File.basename($0) )

server = Server.new( Socket.for_fd(3) )

while true do
  begin
    server.loop
  rescue StandardError => e
    Syslog.log(Syslog::LOG_ERR, 'we got some error: %s', e.message)
    # Syslog.log(Syslog::LOG_ERR, 'we got some error: %s', e.backtrace)
  end

  # XXX This sleep should not be here (in case this works correctly) ...
  # XXX but for development phase I want to avoid busy possible loops.
  # XXX Or should it just be kept? (it needlessly slows down operations)
  sleep 1
end

Syslog.close()
