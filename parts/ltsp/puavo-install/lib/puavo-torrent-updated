#!/usr/bin/ruby

require 'fcntl'
require 'open3'
require 'socket'
require 'syslog'

Target_dir = '/images/rdiffs'
Urlbase = 'https://cdn.opinsys.net'     # XXX this might be something different

class Aria
  attr_reader :stdout, :stderr, :wait_thr

  def initialize(filename)
    @filename = filename

    @outmsg = ''
    @errmsg = ''

    start_download
  end

  def start_download
    url = "#{ Urlbase }/#{ @filename }"

    torrent_filename = "#{ @filename }.torrent"
    filename_fp = "#{ Target_dir }/#{ @filename }"
    tmpfile = "#{ filename_fp }.tmp"

    # XXX we should maybe use rate limit from puavo-conf ?

    aria_args = [ '/usr/bin/env',
                  'LANG=C',
                  'aria2c',
                  '--bt-enable-lpd=true',
                  '--bt-stop-timeout=300',
                  '--ca-certificate=/etc/puavo-conf/rootca.pem',
                  '--check-integrity=true',
                  '--enable-color=false',
                  '--human-readable=false',
                  '--no-conf=true',
                  '--file-allocation=none',               # XXX is this good?
                  '--follow-torrent=mem',
                  "--index-out=1=#{ tmpfile }",
                  '--max-overall-download-limit=10M',     # XXX use rate limit
                  '--max-overall-upload-limit=10M',       # XXX use rate limit
                  '--seed-ratio=0.0',
                  '--summary-interval=1',
                  url ]

    # XXX we probably need --on-download-complete= as well so that we know
    # XXX when we can proceed (rename file and such)

    Syslog.log(Syslog::LOG_NOTICE,
               'starting aria2c with args %s', aria_args.join(' '))

    @stdin, @stdout, @stderr, @wait_thr = Open3.popen3(*aria_args)
    @stdin.fcntl(Fcntl::F_SETFL, Fcntl::O_NONBLOCK)
    @stdout.fcntl(Fcntl::F_SETFL, Fcntl::O_NONBLOCK)
    @stderr.fcntl(Fcntl::F_SETFL, Fcntl::O_NONBLOCK)
  end

  def read_stdout
    begin
      @outmsg += @stdout.read_nonblock(1024)
    rescue EOFError, IOError
      Syslog.log(Syslog::LOG_NOTICE,
                 'we got stdout messages from aria2: %s', @outmsg)
      @stdout.close
      @stdout = nil
    end
  end

  def read_stderr
    begin
      @errmsg += @stderr.read_nonblock(1024)
    rescue EOFError, IOError
      Syslog.log(Syslog::LOG_NOTICE,
                 'we got stderr messages from aria2: %s', @errmsg)
      @stderr.close
      @stderr = nil
    end
  end

  def get_progress
    # XXX we can remove old messages from the queue, no need to go through
    # XXX the old ones...

    progress = nil
    @outmsg.split("\n").each do |line|
      fields = line.split
      next unless fields[1] && fields[5] && fields[5].match(/^ETA/)

      match = fields[1].match(/\((\d+)%\)$/)
      if match then
        progress = match[1]
      end
    end

    progress
  end

  def stop
    # XXX should send some term signal to pid if it still exists
    # XXX and then wait for status
    # use @wait_thr

    @stdin.close  if @stdin
    @stdout.close if @stdout
    @stderr.close if @stderr
  end
end

class Server
  def initialize(server_socket)
    @server_socket = server_socket

    @client_socket = nil
    @filename_to_download = nil
    @read_filename = false

    @aria = nil

    @current_progress = nil
    @write_progress   = false
  end

  def loop
    readable = [ @server_socket ]
    writeable = []

    if @client_socket then
      readable  << @client_socket if @read_filename
      writeable << @client_socket if @write_progress
    end

    if @aria then
      readable << @aria.stdout if @aria.stdout
      readable << @aria.stderr if @aria.stderr
    end

    ios = IO.select(readable, writeable)

    if ios[0].include?(@server_socket) then
      Syslog.log(Syslog::LOG_INFO, 'new client connection')
      if @client_socket then
        # XXX Should shutdown current aria2 instance and client_socket
        # XXX with error.  At least the process should be killed.
        @aria.stop
        @aria = nil
      end

      @client_socket, client_addr = @server_socket.accept_nonblock
      @filename_to_download = ''
      @read_filename = true
    end

    if ios[1].include?(@client_socket) then
      Syslog.log(Syslog::LOG_INFO, 'writing progress to client')
      @client_socket.write("#{ @current_progress }\n")
      @write_progress = false
    end

    if ios[0].include?(@client_socket) then
      begin
        @filename_to_download += @client_socket.read_nonblock(1024)
      rescue EOFError
        @filename_to_download.chomp!
        Syslog.log(Syslog::LOG_NOTICE,
                   "client asks to download '%s'",
                   @filename_to_download)
        @client_socket.shutdown(:RD)
        @read_filename = false

        @current_progress = nil
        @aria = Aria.new(@filename_to_download)
      end
    end

    if @aria then
      @aria.read_stdout if @aria.stdout && ios[0].include?(@aria.stdout)
      @aria.read_stderr if @aria.stderr && ios[0].include?(@aria.stderr)

      new_progress = @aria.get_progress
      if new_progress != @current_progress then
        @current_progress = new_progress
        @write_progress = true
        Syslog.log(Syslog::LOG_NOTICE, 'progress is now %s', @current_progress)
      end

      if @aria.wait_thr && !@aria.stdout && !@aria.stderr then
        status = @aria.wait_thr.value
        Syslog.log(Syslog::LOG_NOTICE, 'we got status from aria: %s', status)
        @aria.stop
        @aria = nil
        @client_socket.write(status.success? ? "OK\n" : "FAIL\n")
        @client_socket.close
      end
    end
  end
end

Syslog.open( File.basename($0) )

server = Server.new( Socket.for_fd(3) )

while true do
  begin
    server.loop
  rescue StandardError => e
    Syslog.log(Syslog::LOG_ERR, 'we got some error: %s', e.message)
    # Syslog.log(Syslog::LOG_ERR, 'we got some error: %s', e.backtrace)
  end

  # XXX This sleep should not be here (in case this works correctly) ...
  # XXX but for development phase I want to avoid busy possible loops.
  # XXX Or should it just be kept? (it needlessly slows down operations)
  sleep 1
end

Syslog.close()
