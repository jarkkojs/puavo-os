#!/usr/bin/ruby

require 'open3'
require 'socket'
require 'syslog'

Target_dir = '/images/rdiffs'
Urlbase = 'https://cdn.opinsys.net'     # XXX this might be something different

class Aria
  attr_reader :filename, :last_msgs, :progress, :stdout, :wait_thr

  def initialize(filename)
    @filename = filename
    @last_msgs = []
    @outmsg   = ''
    @progress = nil

    start_download
  end

  def start_download
    url = "#{ Urlbase }/#{ @filename }.torrent"

    torrent_filename = "#{ @filename }.torrent"
    @filename_fp = "#{ Target_dir }/#{ @filename }"
    @tmpfile = "#{ @filename_fp }.tmp"

    # XXX we should maybe use rate limit from puavo-conf ?

    torrent_update_pid = Process.pid
    download_complete_path \
      = '/usr/lib/puavo-ltsp-install/puavo-torrent-download-complete'

    aria_args = [ '/usr/bin/env',
                  'LANG=C',
                  "PUAVO_TORRENT_UPDATE_PID=#{ torrent_update_pid }",
                  'aria2c',
                  '--bt-enable-lpd=true',
                  '--bt-stop-timeout=300',
                  '--ca-certificate=/etc/puavo-conf/rootca.pem',
                  '--check-integrity=true',
                  '--enable-color=false',
                  '--follow-torrent=mem',
                  '--human-readable=false',
                  "--index-out=1=#{ @tmpfile }",
                  '--max-overall-download-limit=10M',     # XXX use rate limit
                  '--max-overall-upload-limit=10M',       # XXX use rate limit
                  '--no-conf=true',
                  "--on-bt-download-complete=#{ download_complete_path }",
                  '--seed-ratio=0.0',
                  '--summary-interval=1',
                  url ]

    # XXX we probably need as well so that we know
    # XXX when we can proceed (rename file and such)

    Syslog.log(Syslog::LOG_NOTICE,
               'starting aria2c with args %s', aria_args.join(' '))

    stdin, @stdout, stderr, @wait_thr \
      = Open3.popen3(*aria_args, :err => '/dev/null', :in  => '/dev/null')
  end

  def read_stdout
    begin
      new_outmsg = ''
      @outmsg += @stdout.read_nonblock(1024)
      @outmsg.each_line do |line|
        update_progress(line)
        if line.match(/\n$/) then
          @last_msgs = (@last_msgs + [ line ]).last(20)
        else
          new_outmsg = line
        end
      end
      @outmsg = new_outmsg
    rescue EOFError, IOError
      @stdout.close
      @stdout = nil
    end
  end

  def update_progress(line)
    fields = line.split
    return unless fields[1] && fields[5] && fields[5].match(/^ETA/)

    match = fields[1].match(/\((\d+)%\)$/)
    if match then
      @progress = match[1]
    end
  end

  def stop
    if @wait_thr.alive? then
      Process.kill('TERM', @wait_thr.pid)
    end

    @stdout.close if @stdout
    @stdout = nil
  end
end

class Server
  def initialize(server_socket)
    @server_socket = server_socket

    @client_socket = nil
    @filename_to_download = nil
    @read_filename = false

    @aria = nil

    @current_progress = nil
    @write_progress   = false

    @selfpipe_r, @selfpipe_w = IO.pipe
  end

  def loop
    readable = [ @server_socket, @selfpipe_r ]
    writeable = []

    if @client_socket then
      readable  << @client_socket if @read_filename
      writeable << @client_socket if @write_progress
    end

    if @aria then
      readable << @aria.stdout if @aria.stdout
    end

    ios = IO.select(readable, writeable)

    if ios[0].include?(@selfpipe_r) then
      # we got "bt-download-complete" signal from aria2c, all is good and
      # we can close the client connection
      @selfpipe_r.read_nonblock(1)
      if @client_socket then
        @client_socket.write_nonblock("100\n")
        @client_socket.close
        @client_socket = nil
      end
      return
    end

    if ios[0].include?(@server_socket) then
      Syslog.log(Syslog::LOG_INFO, 'new client connection')
      if @client_socket then
        Syslog.log(Syslog::LOG_INFO, 'breaking old client connection')
        @client_socket.close()
        @client_socket = nil
      end

      @client_socket, client_addr = @server_socket.accept_nonblock
      @filename_to_download = ''
      @read_filename = true

      # @client_socket has been switched, must return
      return
    end

    if ios[1].include?(@client_socket) then
      @client_socket.write_nonblock("#{ @current_progress }\n")
      @write_progress = false
    end

    if ios[0].include?(@client_socket) then
      begin
        @filename_to_download += @client_socket.read_nonblock(1024)
      rescue EOFError
        @filename_to_download.chomp!
        Syslog.log(Syslog::LOG_NOTICE,
                   "client asks to download '%s'",
                   @filename_to_download)
        @client_socket.shutdown(:RD)
        @read_filename = false

        @current_progress = nil

        if @aria && @aria.filename != @filename_to_download then
          @aria.stop
          @aria = nil
        end
        if !@aria then
          @aria = Aria.new(@filename_to_download)
        end
      end
    end

    if @aria then
      @aria.read_stdout if @aria.stdout && ios[0].include?(@aria.stdout)

      new_progress = @aria.progress
      if new_progress != @current_progress then
        @current_progress = new_progress
        @write_progress = true
        Syslog.log(Syslog::LOG_INFO,
                   "download progress for '%s' is now %s%%",
                   @aria.filename,
                   @current_progress)
      end

      if @aria.wait_thr && !@aria.stdout then
        status = @aria.wait_thr.value
        if status.success? then
          errmsg = 'aria has exited with success, even though it should be' \
                     + " seeding '%s', this is an error"
          Syslog.log(Syslog::LOG_ERR, errmsg, @aria.filename)
        else
          Syslog.log(Syslog::LOG_ERR,
                     'we got FAILED status code from aria2c (%d): %s',
                     status.exitstatus,
                     @aria.last_msgs.join)
        end
        @aria = nil
        @client_socket.write_nonblock("FAIL\n")
        @client_socket.close
        @client_socket = nil
      end
    end
  end

  def download_complete
    Syslog.log(Syslog::LOG_INFO, 'bittorrent download complete')
    @selfpipe_w.write_nonblock('o')
  end
end

Syslog.open( File.basename($0) )

server = Server.new( Socket.for_fd(3) )

Signal.trap('SIGUSR1', proc { server.download_complete })

while true do
  begin
    server.loop
  rescue StandardError => e
    Syslog.log(Syslog::LOG_ERR, 'we got some unexpected error: %s', e.message)
    exit(1)
  end
end

Syslog.close()
