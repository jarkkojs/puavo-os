#!/usr/bin/ruby

require 'highline/import'
require 'net/http'
require 'puavo/etc'
require 'puavo/rest-client'
require 'syslog'

def log(level, channel, priority, msg, color)
  logmsg = prefixed_logmsg(level, msg)

  Syslog.log(priority, "%s", logmsg)

  outmsg = color  ?  HighLine.new.color(logmsg, color)  :  logmsg
  channel.puts(outmsg)
end

def prefixed_logmsg(level, msg)
  spacecount = [5, [5-level, 0].max ].min       # (5-level between [0,5])
  arrowcount = [0, [  level, 5].min ].max       # (  level between [0,5])
  "%s %s" % [ (" " * spacecount  +  ">" * arrowcount),
              msg ]
end

def info(level, msg, color=nil)
  log(level, STDOUT, Syslog::LOG_INFO, msg, color)
end

def warning(level, msg)
  log(level, STDERR, Syslog::LOG_WARNING, "WARNING: #{ msg }", HighLine::RED)
end

class SyncState
  StatesAndMessages = {
    :missing    => "%s is missing",
    :downloaded => "%s has been downloaded",
    :unverified => "%s is unverified",
    :inplace    => "%s is inplace",
    :deleted    => "%s has been deleted",
    :unknown    => "%s state is unknown",
  }

  def initialize()
    @state = :unknown
  end
end

class SyncFile
  attr_reader :filename

  def initialize(filename, dir=nil)
    raise 'filename is not set' \
      unless filename && filename.kind_of?(String) && !filename.empty?

    @basedir  = dir || self.class.basedir
    @filename = File.basename(filename)
  end
end

class SyncFileWithMetadata < SyncFile
  attr_accessor :priority
  attr_reader :cksum, :size

  def initialize(cksum, filename, sha256, size, urls)
    super(filename)

    raise 'sha256 is not set' \
      unless sha256 && sha256.kind_of?(String) && !sha256.empty?
    raise 'size is not set' \
      unless size && size.kind_of?(Integer)
    raise 'urls are not set' \
      unless urls && urls.kind_of?(Array) && !urls.empty? \
                  && urls.all? { |url| url.kind_of?(String) }

    @cksum  = cksum
    @sha256 = sha256
    @size   = size
    @urls   = urls

    @in_use        = 0
    @mtime         = nil
    @priority      = nil
    @state         = SyncState.new
    @verified      = false
    @verify_result = false
  end
end

class Image < SyncFileWithMetadata
  attr_reader :id, :version

  def initialize(cksum, filename, id, sha256, size, urls, version, series)
    super(cksum, filename, sha256, size, urls)

    raise 'id is not set' \
      unless id && id.kind_of?(String) && !id.empty?
    raise 'version is not set' \
      unless version && version.kind_of?(String) && !version.empty?

    @id = id
    @series = series
    @version = version

    @diffs_from_by_version = {}
  end

  def self.basedir; $config[:download_path]; end

  def add_diff(diff)
    return unless diff.targetimage.version == @version

    if diff.baseimage.version != @version then
      @diffs_from_by_version[diff.baseimage.version] = diff
    end
  end

  def diffs
    return @diffs_from_by_version.values
  end

  def diffs_newest_first
    return @diffs_from_by_version.sort.map { |version, diff| diff }.reverse
  end

  def set_priorities(base_priority, priority_adjustments)
    # XXX use priority_adjustments

    @priority = next_diff_priority = base_priority

    diffs_newest_first.each do |diff|
      diff.priority = next_diff_priority
      next_diff_priority = (next_diff_priority/2).floor
    end
  end
end

class Diff < SyncFileWithMetadata
  attr_reader :baseimage, :targetimage

  def initialize(cksum, baseimage, targetimage, filename, sha256, size, urls)
    super(cksum, filename, sha256, size, urls)

    @baseimage   = baseimage
    @targetimage = targetimage
  end

  def self.basedir; "#{ $config[:download_path] }/rdiffs"; end
end

class Series
  attr_reader :series_name

  def initialize(name)
    @series_name = name

    @by_id = {}
    @by_version = {}
  end

  def add_image(image)
    @by_id[image.id] = @by_version[image.version] = image
  end

  def add_diff(cksum, from_version, to_version, filename, sha256, size, urls)
    baseimage = get_by_version(from_version)
    targetimage = get_by_version(to_version)

    if baseimage && targetimage then
      diff = Diff.new(cksum, baseimage, targetimage, filename, sha256, size,
                      urls)
      targetimage.add_diff(diff)
    end
  end

  def get_by_version(version)
    return @by_version[version]
  end

  def images
    return @by_version.values
  end

  def images_newest_first
    return @by_version.sort.map { |version, image| image }.reverse
  end

  def set_priorities(priority_adjustments)
    # XXX use priority_adjustments

    priority = 1024
    images_newest_first.each do |image|
      image.set_priorities(priority, priority_adjustments)
      priority = (priority/4).floor
    end

    images_newest_first.each do |image|
      info(4, "image #{ image.id } has priority #{ image.priority }") \
        if image.priority > 0
      image.diffs_newest_first.each do |diff|
        info(3, "  diff #{ diff.filename } has priority #{ diff.priority }") \
          if diff.priority > 0
      end
    end

    # XXX ?
  end
end

module SeriesControl
  # Load series json definition files
  def self.fetch_and_parse_series_data(source_url)
    info(5, "Using image series source url #{ source_url }")

    uri = URI.parse(source_url)

    http = Net::HTTP.new(uri.host, uri.port)
    http.ca_file = '/etc/puavo-conf/rootca.pem'
    http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    http.use_ssl = true

    series_by_name = {}
    http.request_get(uri.path) do |response|
      if !response.kind_of?(Net::HTTPOK) then
        # Do not let a failed fetch slip out as empty series... otherwise
        # temporary download failure might result in removing all images/diffs
        # in this series.
        raise "Error in fetching #{ source_url }," \
                + " response code #{ response.code }"
      end

      series_by_name = parse_series_data( JSON.parse( response.body ) )
    end

    return series_by_name
  end

  def self.get_all_series(bootserver_data)
    all_series_list = []
    series_urls = Array(bootserver_data['image_series_source_urls'])

    if series_urls.empty? then
      info(5, "No series urls were defined")
    else
      series_urls.each do |series_url|
        all_series_list << fetch_and_parse_series_data(series_url)
      end
    end

    all_series = all_series_list.reduce(&:merge) || []

    if all_series.empty? then
      raise "No series information, can not do anything"
    end

    return all_series.values
  end

  def self.get_bootserver_data
    url = "/v3/boot_servers/#{ @etc.hostname }"
    info(5, "Loading bootserver data from puavo-rest url: #{ url }")
    res = @client.get(url)
    return res.parse()
  end

  def self.get_device_bootmode(device)
    # XXX It should be possible to lookup bootmode from device['boot_mode']
    # XXX and it should be either netboot or localboot, but because of
    # XXX bugs in Puavo some localboot devices may be set to 'netboot'.
    # XXX Thus, check out object classes to figure out the correct bootmode.
    object_classes = device['object_classes']
    if !object_classes.kind_of?(Array) then
      errmsg = "Could not determine object classes for #{ hostname }"
      warning(3, errmsg)
      raise errmsg
    end

    return object_classes.include?('puavoNetbootDevice') \
             ? 'netboot'                                 \
             : 'localboot'
  end

  def self.get_devices()
    attributes = %w(current_image hostname object_classes preferred_image
                    puavo_id school_dn)
    res = @client.get('/v3/devices',
                      :params => { :attributes => attributes.join(',') })
    return res.parse()
  end

  def self.get_diff_filename(from_image, to_image)
    # Determine diff filename simply from from_image and to_image strings,
    # without looking at the series data.  We might have diffs that cross
    # from one series to another and those will look like diffs on the
    # originating series (from-image), but should be listed as diffs to the
    # target image.  The diff we return here might not exist in any series
    # but here we do not care about that, at least we could record (elsewhere)
    # what we are missing.
    img_regex = /^(.*?)-([0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{6})-(.*?)$/

    from_match = from_image.match(img_regex)
    raise "could not find timestamp in #{ from_image }" unless from_match
    to_match = to_image.match(img_regex)
    raise "could not find timestamp in #{ to_image }" unless to_match

    return sprintf('%s-%s--%s-%s.rdiff', from_match[1], from_match[2],
                   to_match[2], from_match[3])
  end

  def self.get_priority_adjustments_by_devices(all_series, bootserver_data)
    info(5, "Checking which images/diffs are needed by bootserver/devices")

    adjustments = {
      :diffs  => {},
      :images => {},
    }

    device_list = get_devices()

    bootserver_school_dn_list = Array( bootserver_data['school_dns'] )

    bootserver_current_image   = bootserver_data['current_image']
    bootserver_preferred_image = bootserver_data['preferred_image']
    if bootserver_preferred_image then
      # image used by the bootserver itself must have a high priority
      # image currently used by the bootserver itself must also have a high
      # priority (even higher)
      adjustments[:images][ bootserver_data['preferred_image'] ] = 1000000
    end
    if bootserver_current_image && bootserver_preferred_image \
        && bootserver_current_image != bootserver_preferred_image then
          # bootserver may want a diff for an update
          begin
            diff = get_diff_filename(bootserver_current_image,
                                     bootserver_preferred_image)
            adjustments[:diffs][diff] = 1100000
          rescue StandardError => e
            warning(3,
                    "error in determining diff filename for #{ hostname }:" \
                      + " #{ e.message }")
          end

    end

    device_list.each do |device|
      current_image   = device['current_image']
      hostname        = device['hostname']
      preferred_image = device['preferred_image']
      puavo_id        = device['puavo_id']
      school_dn       = device['school_dn']

      if !hostname || hostname.empty? then
        warning(3, "There is a device in Puavo (#{ puavo_id }) that does not" \
                     + ' have a hostname')
        next
      end
      if !school_dn || school_dn.empty? then
        warning(3, "Host #{ hostname } is not associated with any school," \
                     + ' ignoring.')
        next
      end

      # Skip hosts that are not served by this bootserver.
      next unless bootserver_school_dn_list.include?(school_dn)

      bootmode = get_device_bootmode(device) rescue nil
      next unless bootmode
      if bootmode == 'netboot' then
        # fatclients are important because they do not work unless they have
        # the image they request
        next unless preferred_image
        adjustments[:images][preferred_image] \
          = (adjustments[:images][preferred_image] || 0) + 7
        next
      end

      if current_image && preferred_image \
        && current_image != preferred_image then
          # laptops want diffs
          begin
            diff = get_diff_filename(current_image, preferred_image)
            adjustments[:diffs][diff] = (adjustments[:diffs][diff] || 0) + 2
          rescue StandardError => e
            warning(3,
                    "error in determining diff filename for #{ hostname }:" \
                      + " #{ e.message }")
          end
      end
    end

    return adjustments
  end

  def self.parse_series_data(series_data)
    series_by_name = Hash.new

    series_data.each_pair do |series_name, data|
      series = Series.new(series_name)

      data['images'].each do |imagedata|
        image = Image.new(imagedata['cksum'],
                          imagedata['filename'],
                          imagedata['id'],
                          imagedata['sha256'],
                          imagedata['size'],
                          imagedata['urls'],
                          imagedata['version'],
                          series)
        series.add_image(image)
      end

      data['images'].each do |image|
        if image['diffs'] then
          image['diffs'].each do |diffdata|
            series.add_diff(diffdata['cksum'],
                            diffdata['version'],
                            image['version'],
                            diffdata['filename'],
                            diffdata['sha256'],
                            diffdata['size'],
                            diffdata['urls'])
          end
        end
      end

      series_by_name[series_name] = series
    end

    series_by_name
  end

  def self.sync_all_series
    @etc    = PuavoEtc.new
    @client = PuavoRestClient.new :auth => :etc

    bootserver_data = SeriesControl::get_bootserver_data()

    all_series = get_all_series(bootserver_data)
    begin
      write_cksums_for_laptops(all_series)
    rescue StandardError => e
      warning(5, "Could not write CKSUMS file for laptops: #{ e.message }")
    end

    priority_adjustments \
      = get_priority_adjustments_by_devices(all_series, bootserver_data)
    p priority_adjustments
    exit 1

    all_series.each do |series|
      series.set_priorities(priority_adjustments)
    end
  end

  def self.write_cksums_for_laptops(all_series)
    syncfiles = {}

    all_series.each do |series|
      series.images.each do |image|
        next unless image.cksum && image.filename && image.size
        syncfiles[ image.filename ] = image
        image.diffs.each { |diff| syncfiles[ diff.filename ] = diff }
      end
    end

    cksums_file_contents \
      = syncfiles.values \
                 .map { |sf| [sf.cksum, sf.size, sf.filename].join(' ') } \
                 .uniq.map { |s| "#{ s }\n" }.join

    raise "Download path #{ $config[:download_path] } is not a directory" \
      unless File.directory?($config[:download_path])

    cksums_file = "#{ $config[:download_path] }/CKSUMS"

    if $config[:dry_run] then
      info(5, "Not writing #{ cksums_file } (dry-run)")
      return
    end

    tmpfile = "#{ cksums_file }.tmp"
    File.open(tmpfile, 'w') { |f| f.write cksums_file_contents }
    File.rename(tmpfile, cksums_file)

    info(5, "Wrote #{ cksums_file }")
  end
end

exitstatus = 0

script_name = File.basename(__FILE__)
Syslog.open(script_name, Syslog::LOG_CONS)

$config = {
  :download_path => '/images',
  :dry_run       => false,
}

parser = OptionParser.new do |opts|
  opts.on('--dry-run', 'Only show what should be done, yet do nothing') do
    $config[:dry_run] = true
  end
end
parser.parse!

begin
  SeriesControl::sync_all_series()
rescue StandardError => e
  warning(5, "ERROR: #{ e.message }")
  exitstatus = 1
end

Syslog.close()

exit(exitstatus)
