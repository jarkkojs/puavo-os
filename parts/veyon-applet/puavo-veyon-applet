#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import dbus
import dbus.mainloop.glib
import gettext
import gi
import netifaces
import random
import re
import signal
import socket
import string
import struct
import subprocess
import sys
import zeroconf

gi.require_version('AyatanaAppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AyatanaAppIndicator3
from gi.repository import GLib
from gi.repository import Gtk
from gi.repository import Notify

gettext.bindtextdomain('puavo-veyon-applet', '/usr/share/locale')
gettext.textdomain('puavo-veyon-applet')
_tr = gettext.gettext

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


def read_firstline(pathname):
  with open(pathname) as file:
    return (file.readlines())[0].rstrip("\n")


# XXX is this needed?
class PuavoWidget:
  def connect_to_dbus(self, bus_name, service, interface):
    self.bus = dbus.SystemBus()
    dbusobj = self.bus.get_object(bus_name, service)
    return dbus.Interface(dbusobj, dbus_interface=interface)


  # XXX is this needed?
  def notify(self, summary, body=None):
    # no notifications if running on login screen
    if getpass.getuser() == 'Debian-gdm':
      return

    if body:
      Notify.Notification.new(summary, body).show()
    else:
      Notify.Notification.new(summary).show()


class Veyon():
  SERVICE_TYPE = '_http._tcp.local.'
  SERVICE_NAME = 'VeyonMaster._http._tcp.local.'
  SERVICE_PORT = 2991   # XXX why this one?

  def receive_msg(socket):
    # XXX what if we do not receive four bytes?
    # XXX how do we know that connection is closed?
    size = socket.recv(4)
    # XXX what if all of the message can not be read at once?
    msgsize = struct.unpack('!i', size)[0]
    message = json.loads( socket.recv(msgsize) )
    print('received message %s' % message)
    return message


  def send_msg(socket, message):
    message = bytes(json.dumps(message), encoding='utf-8')
    msgsize = len(message)
    socket.send(struct.pack('!i', msgsize))
    socket.send(message)
    print('sent message %s' % message)


class VeyonClient(PuavoWidget):
  def __init__(self, master, client_socket):
    self.client_socket = client_socket
    self.master = master
    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.client_socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.incoming_client_data,
                      self.client_socket)


  def incoming_client_data(self, io, cond, client_socket):
    message = Veyon.receive_msg(client_socket)

    if not 'type' in message:
      # XXX error handling?
      return

    # XXX we should also check value types in each case

    if message['type'] == 'new_client':
      if not 'hostname' in message:
        # XXX error handling?
        return
      self.hostname = message['hostname']
      self.send_pin_request()
    elif message['type'] == 'public_key_request':
      if not 'pin' in message:
        # XXX error handling?
        return
      if message['pin'] == self.master.pin:
        self.send_public_key()
      else:
        Veyon.send_msg(self.client_socket, { 'type': 'wrong_pin' })

    return True

    return True


  def send_pin_request(self):
    Veyon.send_msg(self.client_socket, { 'type': 'pin_request' })


  def send_public_key(self):
    msg = { 'type': 'veyon_public_key', 'public_key': self.master.public_key }
    Veyon.send_msg(self.client_socket, msg)



class VeyonMaster(PuavoWidget):
  def __init__(self, menu):
    self.public_key = None

    self.pin_label = Gtk.MenuItem()
    self.create_new_pin()
    self.pin_label.show()
    self.pin_label.set_sensitive(False)
    menu.append(self.pin_label)

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/master',
                                           'org.puavo.Veyon.master')
    self.dbus_iface \
        .GetPublicKey(reply_handler=self.handle_get_public_key,
                      error_handler=self.handle_get_public_key_error)


  def set_pin(self, new_pin):
    self.pin = new_pin
    self.pin_label.set_label('PIN: %s' % new_pin)


  def create_new_pin(self):
    random_pin = ''.join(random.choices(string.digits, k=4))
    self.set_pin(random_pin)


  def handle_get_public_key(self, public_key):
    self.public_key = public_key
    self.setup_master_service()


  def handle_get_public_key_error(self, dbusexception):
    # XXX
    print("oh no public key dbus error")


  def setup_master_service(self):
    host_ip_addresses = []
    for intf in netifaces.interfaces():
      if re.match('^(lo|tun|vpn)', intf):
        continue
      for ip_addr in netifaces.ifaddresses(intf)[netifaces.AF_INET]:
        if 'addr' in ip_addr:
          host_ip_addresses.append(
            socket.inet_pton(socket.AF_INET, ip_addr['addr']))

    if len(host_ip_addresses) == 0:
      # XXX should we give some error if host has no ip addresses?
      self.zeroconf = None
      return

    self.zeroconf = zeroconf.Zeroconf()

    serviceinfo = zeroconf.ServiceInfo(Veyon.SERVICE_TYPE,
                                       Veyon.SERVICE_NAME,
                                       addresses=host_ip_addresses,
                                       port=Veyon.SERVICE_PORT)
    self.zeroconf.register_service(serviceinfo)

    self.socket = socket.socket()
    self.socket.bind(('0.0.0.0', Veyon.SERVICE_PORT))
    self.socket.listen()

    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.handle_incoming,
                      self.socket)


  def handle_incoming(self, io, cond, sock):
    conn = sock.accept()[0]
    # XXX there could be many clients, this supports only one
    self.veyon_client = VeyonClient(self, conn)

    return True


class VeyonListener():
  def __init__(self, veyon_slave):
    self.veyon_slave = veyon_slave


  def add_service(self, zeroconf, type, name):
    if type == Veyon.SERVICE_TYPE and name == Veyon.SERVICE_NAME:
      service = zeroconf.get_service_info(type, name)
      self.veyon_slave.set_veyon_master(service)
      self.veyon_slave.open_connection()


  def remove_service(self, zeroconf, type, name):
    if type == Veyon.SERVICE_TYPE and name == Veyon.SERVICE_NAME:
      self.veyon_slave.set_veyon_master(None)


class VeyonSlave(PuavoWidget):
  def __init__(self, menu):
    self.zeroconf = zeroconf.Zeroconf()
    self.hostname = read_firstline('/etc/puavo/hostname')

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/slave',
                                           'org.puavo.Veyon.slave')

    service = self.zeroconf.get_service_info(Veyon.SERVICE_TYPE,
                                             Veyon.SERVICE_NAME)
    self.set_veyon_master(service)
    self.open_connection()
    self.browser = zeroconf.ServiceBrowser(self.zeroconf,
                                           Veyon.SERVICE_NAME,
                                           VeyonListener(self))


  def set_veyon_master(self, service_info):
    self.veyon_master = service_info


  def open_connection(self):
    if not self.veyon_master:
      return

    # XXX if there is a new master, we should close the old socket connection

    self.master_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # XXX this picks the first one, but what if we do not have any?
    host_ip = socket.inet_ntop(socket.AF_INET,
                               self.veyon_master.addresses[0])
    host_port = self.veyon_master.port

    if host_ip and host_port:
      self.master_socket.connect((host_ip, host_port))
      message = { 'type': 'new_client', 'hostname' : self.hostname }
      Veyon.send_msg(self.master_socket, message)

      # XXX should this be asynchronous?
      GLib.io_add_watch(GLib.IOChannel(self.master_socket.fileno()),
                        0,
                        GLib.IOCondition.IN,
                        self.incoming_master_data,
                        self.master_socket)


  def send_public_key_request(self, pin):
    msg = { 'type': 'public_key_request', 'pin': pin }
    Veyon.send_msg(self.master_socket, msg)


  def incoming_master_data(self, io, cond, master_socket):
    message = Veyon.receive_msg(master_socket)

    if not 'type' in message:
      # XXX error handling
      return

    if message['type'] == 'pin_request':
      # XXX show pin request instead of sending directly
      # XXX the pin given by user should be sent instead of 1234
      self.send_public_key_request('1234')
    elif message['type'] == 'public_key':
      if not 'public_key' in message:
        # XXX error handling
        return
      self.set_veyon_public_key(message['public_key'])
    elif message['type'] == 'wrong_pin':
      # XXX error handling
      return

    return True


  def set_veyon_public_key(self, public_key):
    self.dbus_iface.AddPublicKey(public_key,
                                 reply_handler=self.handle_add_public_key,
                                 error_handler=self.handle_add_public_key_error)


  def handle_add_public_key(self):
    # XXX response handling?
    pass


  def handle_add_public_key_error(dbusexception):
    # XXX response handling?
    pass


class PuavoVeyonApplet:
  def __init__(self):
    # XXX the icon should be something else and maybe puavo-conf configurable?
    self.indicator \
      = AyatanaAppIndicator3.Indicator.new('puavo-veyon-applet',
          '/usr/share/icons/gnome/scalable/places/poi-school.svg',
          AyatanaAppIndicator3.IndicatorCategory.SYSTEM_SERVICES)

    self.indicator.set_status(AyatanaAppIndicator3.IndicatorStatus.ACTIVE)

    Notify.init('puavo-veyon-applet')

    try:
      veyon_role = puavoconf_get('puavo.veyon.role')
    except Exception as e:
      print('puavo.veyon.role could not be determined: %s' % e,
            file=sys.stderr)
      sys.exit(1)

    if veyon_role == '':
      sys.exit(0)
    elif veyon_role != 'master' and veyon_role != 'slave':
      print('unknown veyon role %s' % veyon_role, file=sys.stderr)
      sys.exit(1)

    menu = Gtk.Menu()
    role_label = Gtk.MenuItem(label='Veyon role: %s' % veyon_role)
    role_label.show()
    role_label.set_sensitive(False)
    menu.append(role_label)

    if veyon_role == 'master':
      VeyonMaster(menu)
    else:
      VeyonSlave(menu)

    menu.show_all()

    self.indicator.set_menu(menu)


  def main(self):
    Gtk.main()


applet = PuavoVeyonApplet()

if __name__ == '__main__':
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet.main()
