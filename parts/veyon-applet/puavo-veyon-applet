#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import dbus
import dbus.mainloop.glib
import gettext
import gi
import json
import netifaces
import random
import re
import signal
import socket
import string
import struct
import subprocess
import sys
import time
import zeroconf

gi.require_version('AyatanaAppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AyatanaAppIndicator3
from gi.repository import GLib
from gi.repository import Gtk
from gi.repository import Notify

gettext.bindtextdomain('puavo-veyon-applet', '/usr/share/locale')
gettext.textdomain('puavo-veyon-applet')
_tr = gettext.gettext

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


def read_firstline(pathname):
  with open(pathname) as file:
    return (file.readlines())[0].rstrip("\n")


# XXX is this needed?
class PuavoWidget:
  def connect_to_dbus(self, bus_name, service, interface):
    self.bus = dbus.SystemBus()
    dbusobj = self.bus.get_object(bus_name, service)
    return dbus.Interface(dbusobj, dbus_interface=interface)


  # XXX is this needed?
  def notify(self, summary, body=None):
    # no notifications if running on login screen
    if getpass.getuser() == 'Debian-gdm':
      return

    if body:
      Notify.Notification.new(summary, body).show()
    else:
      Notify.Notification.new(summary).show()


class Veyon():
  SERVICE_TYPE = '_http._tcp.local.'
  SERVICE_BASE = 'VeyonMaster._http._tcp.local.'
  SERVICE_PORT = 2991

  def receive_msg(socket):
    size = socket.recv(4)
    if len(size) != 4:
      raise Exception('no message size, connection closed')

    msgsize = struct.unpack('!i', size)[0]
    message_json = socket.recv(msgsize)
    if len(message_json) != msgsize:
      raise Exception('no message, connection closed')

    message = json.loads(message_json)
    print('received message %s' % message)      # XXX
    return message


  def send_msg(socket, message):
    message = bytes(json.dumps(message), encoding='utf-8')
    msgsize = len(message)
    socket.send(struct.pack('!i', msgsize))
    socket.send(message)
    print('sent message %s' % message)          # XXX


class VeyonSlaveConnection(PuavoWidget):
  def __init__(self, master, slave_socket, slave_address):
    self.slave_socket = slave_socket
    self.address = slave_address[0]    # take only the IP address
    print('VeyonSlaveConnection() = %s' % self.address)
    self.master = master
    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.slave_socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.incoming_slave_data,
                      self.slave_socket)


  def incoming_slave_data(self, io, cond, slave_socket):
    try:
      message = Veyon.receive_msg(slave_socket)
    except Exception as e:
      self.master.remove_slave(self.address)
      return

    if not 'type' in message:
      # XXX error handling?
      return

    # XXX we should also check value types in each case

    if message['type'] == 'new_client':
      if not 'hostname' in message:
        # XXX error handling?
        return
      # XXX we would also like 'location' and 'address' ...
      # XXX we probably already have the address through socket but not
      # XXX location
      self.hostname = message['hostname']
      self.send_pin_request()
    elif message['type'] == 'public_key_request':
      if not 'pin' in message:
        # XXX error handling?
        return
      if message['pin'] == self.master.pin:
        self.send_public_key()
        self.master.update_config()
      else:
        Veyon.send_msg(self.slave_socket, { 'type': 'wrong_pin' })

    return True

    return True


  def send_pin_request(self):
    Veyon.send_msg(self.slave_socket, { 'type': 'pin_request' })


  def send_public_key(self):
    msg = { 'type': 'public_key', 'public_key': self.master.public_key }
    Veyon.send_msg(self.slave_socket, msg)


  def disconnect_slave(self):
    self.slave_socket.shutdown(socket.SHUT_RDWR)
    self.slave_socket.close()


class VeyonMaster(PuavoWidget):
  def __init__(self, menu):
    self.public_key = None
    self.update_config_call_pending = False
    self.veyon_slaves = {}

    self.pin_label = Gtk.MenuItem()
    self.create_new_pin()
    self.pin_label.show()
    self.pin_label.set_sensitive(False)
    menu.append(self.pin_label)

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/master',
                                           'org.puavo.Veyon.master')
    self.dbus_iface \
        .GetPublicKey(reply_handler=self.handle_get_public_key,
                      error_handler=self.handle_get_public_key_error)


  def set_pin(self, new_pin):
    self.pin = new_pin
    self.pin_label.set_label('PIN: %s' % new_pin)


  def create_new_pin(self):
    # XXX we should try to make sure this PIN is unique on the network
    # XXX perhaps deriving it from host IP address will help with that?
    random_pin = ''.join(random.choices(string.digits, k=4))
    self.set_pin(random_pin)


  def handle_get_public_key(self, public_key):
    self.public_key = public_key
    self.setup_master_service()


  def handle_get_public_key_error(self, dbusexception):
    # XXX response handling?
    print('oh no public key dbus error: %s' % dbusexception)


  def setup_master_service(self):
    host_ip_address = None
    for intf in sorted(netifaces.interfaces()):
      if not re.match('^(eth|wlan)', intf):
        continue
      for ip_addr in netifaces.ifaddresses(intf)[netifaces.AF_INET]:
        if 'addr' in ip_addr:
          # pick the first IP address we got that is not localhost or tun*/vpn*
          # (if we would use several on the same host, that might get tricky)
          host_ip_address = ip_addr['addr']
          break

    if not host_ip_address:
      # XXX we should give some error if host has no usable ip address?
      # XXX or perhaps we could wait for it to come?
      # XXX or perhaps we should setup master service only after user wants to
      # XXX setup one, so this could be triggered many times?
      self.zeroconf = None
      return

    self.socket = socket.socket()
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.socket.bind((host_ip_address, Veyon.SERVICE_PORT))
    self.socket.listen()

    self.zeroconf = zeroconf.Zeroconf()

    host_ip_addresses = [ socket.inet_pton(socket.AF_INET, host_ip_address) ]
    my_service_name = self.make_service_name()
    serviceinfo = zeroconf.ServiceInfo(Veyon.SERVICE_TYPE,
                                       my_service_name,
                                       addresses=host_ip_addresses,
                                       port=Veyon.SERVICE_PORT)
    self.zeroconf.register_service(serviceinfo)

    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.handle_new_slave,
                      self.socket)


  def make_service_name(self):
    hostname = read_firstline('/etc/puavo/hostname')
    time_seconds = str(int(time.time()))
    return (hostname + '_' + time_seconds + '.' + Veyon.SERVICE_BASE)


  def handle_new_slave(self, io, cond, sock):
    (conn, slave_address) = sock.accept()
    if slave_address in self.veyon_slaves:
      self.remove_slave(slave_address)
    slave = VeyonSlaveConnection(self, conn, slave_address)
    self.veyon_slaves[slave.address] = slave

    return True


  def update_config(self):
    self.update_config_hosts = []
    for slave in self.veyon_slaves.values():
      host = {
        'address':  slave.address,
        'hostname': slave.hostname,
        'location': 'Classroom',
      }
      self.update_config_hosts.append(host)

    if self.update_config_call_pending:
      return

    # UpdateConfig must not be called more than 10 times in a minute
    GLib.timeout_add_seconds(6, self.dbus_update_config)
    self.update_config_call_pending = True


  def dbus_update_config(self):
    self.update_config_call_pending = False
    self.dbus_iface \
        .UpdateConfig(json.dumps(self.update_config_hosts),
                      reply_handler=self.handle_update_config,
                      error_handler=self.handle_update_config_error)


  def handle_update_config(self):
    # XXX ?
    pass


  def handle_update_config_error(self, dbusexception):
    # XXX ?
    print('oh no update config dbus error: %s' % str(dbusexception))
    pass


  def remove_slave(self, address):
    self.veyon_slaves[address].disconnect_slave()
    del(self.veyon_slaves[address])



class VeyonMasterConnection():
  def __init__(self, address, port, slave):
    self.master_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.slave = slave

    self.address = address
    self.master_socket.connect((self.address, port))

    message = { 'type': 'new_client', 'hostname' : self.slave.hostname }
    Veyon.send_msg(self.master_socket, message)

    self.slave.pin_entry_button.set_sensitive(True)

    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.master_socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.incoming_master_data,
                      self.master_socket)


  def incoming_master_data(self, io, cond, master_socket):
    try:
      message = Veyon.receive_msg(master_socket)
    except Exception as e:
      self.slave.remove_master(self.address)
      return

    if not 'type' in message:
      # XXX error handling
      return

    if message['type'] == 'pin_request':
      # XXX perhaps we should not active pin entry here, but we could at least
      # XXX make it possible to do that on some condition?
      self.slave.activate_pin_entry()
    elif message['type'] == 'public_key':
      if not 'public_key' in message:
        # XXX error handling
        return
      self.slave.set_veyon_public_key(message['public_key'])
    elif message['type'] == 'wrong_pin':
      # XXX error handling
      return

    return True


  def send_public_key_request(self, pin):
    msg = { 'type': 'public_key_request', 'pin': pin }
    Veyon.send_msg(self.master_socket, msg)


  def disconnect_master(self):
    self.master_socket.shutdown(socket.SHUT_RDWR)
    self.master_socket.close()


class VeyonSlave(PuavoWidget):
  def __init__(self, menu):
    self.zeroconf = zeroconf.Zeroconf()
    self.hostname = read_firstline('/etc/puavo/hostname')

    self.veyon_masters = {}

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/slave',
                                           'org.puavo.Veyon.slave')

    self.pin_entry_button = Gtk.MenuItem(label='Join a Veyon session')
    self.pin_entry_button.show()
    self.pin_entry_button.set_sensitive(False)
    self.pin_entry_button.connect('activate', self.activate_pin_entry)
    menu.append(self.pin_entry_button)

    # XXX does this pick up many or only one?
    service = self.zeroconf.get_service_info(Veyon.SERVICE_TYPE,
                                             Veyon.SERVICE_NAME)
    self.add_master(service)
    self.browser = zeroconf.ServiceBrowser(self.zeroconf,
                                           Veyon.SERVICE_NAME,
                                           VeyonSlaveListener(self))


  def add_master(self, service):
    # XXX what if this raises an expection?
    # XXX should we only use the first one?  what if there are no addresses?
    # XXX could there be several immediately?
    print('service = %s' % service)
    for srv_address in service.addresses:
      address = str(socket.inet_ntop(socket.AF_INET, srv_address))
      print('add master address=%s port=%s' % (address, service.port))

    # sys.exit(0)

    # self.veyon_masters[address] = VeyonMasterConnection(address, port, self)


  def remove_master(self, address):
    if not address in self.veyon_masters:
      return

    self.veyon_masters[address].disconnect_master()
    del(self.veyon_masters[address])


  def activate_pin_entry(self, widget=None):
    self.label = Gtk.Label(label='Provide a PIN for Veyon session:')

    self.pin_entry = Gtk.Entry()
    self.pin_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)
    self.pin_entry.set_max_length(4)
    self.pin_entry.set_width_chars(4)
    self.pin_entry.connect('changed', self.pin_entry_changed)

    self.box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
    self.box.pack_start(self.label, True, True, 3)
    self.box.pack_start(self.pin_entry, True, True, 3)

    self.alignment = Gtk.Alignment(xalign=0.5, yalign=0.5, xscale=0, yscale=0)
    self.alignment.add(self.box)

    self.pin_window = Gtk.Window()
    self.pin_window.set_opacity(0.5)
    self.pin_window.fullscreen()

    self.pin_window.add(self.alignment)
    self.pin_window.show_all()


  def pin_entry_changed(self, entry):
    entry.handler_block_by_func(self.pin_entry_changed)
    new_text = ''.join([c for c in entry.get_text() if c in string.digits])
    entry.set_text(new_text)
    entry.handler_unblock_by_func(self.pin_entry_changed)
    if len(new_text) == 4:
      # XXX we probably need some connect buttons and exit buttons instead
      # XXX of this, but this can be used for testing
      for master_connection in self.veyon_masters.values():
        master_connection.send_public_key_request(new_text)
      self.pin_window.destroy()


  def set_veyon_public_key(self, public_key):
    self.dbus_iface.AddPublicKey(public_key,
                                 reply_handler=self.handle_add_public_key,
                                 error_handler=self.handle_add_public_key_error)


  def handle_add_public_key(self):
    # XXX response handling?
    # XXX perhaps notification that communication has been established?
    pass


  def handle_add_public_key_error(self, dbusexception):
    # XXX response handling?
    print('oh no add public key dbus error: %s' % str(dbusexception))


class VeyonSlaveListener():
  def __init__(self, slave):
    self.slave = slave


  def add_service(self, zeroconf, type, name):
    if type == Veyon.SERVICE_TYPE and name == Veyon.SERVICE_NAME:
      service = zeroconf.get_service_info(type, name)
      print('add service %s' % service)
      self.slave.add_master(service)


  def remove_service(self, zeroconf, type, name):
    if type == Veyon.SERVICE_TYPE and name == Veyon.SERVICE_NAME:
      service = zeroconf.get_service_info(type, name)
      for srv_address in service.addresses:
        address = socket.inet_ntop(socket.AF_INET, srv_address)
        print('removing address %s' % address)
        self.slave.remove_master(address)


class PuavoVeyonApplet:
  def __init__(self):
    # XXX the icon should be something else and maybe puavo-conf configurable?
    self.indicator \
      = AyatanaAppIndicator3.Indicator.new('puavo-veyon-applet',
          '/usr/share/icons/gnome/scalable/places/poi-school.svg',
          AyatanaAppIndicator3.IndicatorCategory.SYSTEM_SERVICES)

    self.indicator.set_status(AyatanaAppIndicator3.IndicatorStatus.ACTIVE)

    Notify.init('puavo-veyon-applet')

    try:
      veyon_role = puavoconf_get('puavo.veyon.role')
    except Exception as e:
      print('puavo.veyon.role could not be determined: %s' % e,
            file=sys.stderr)
      sys.exit(1)

    if veyon_role == '':
      sys.exit(0)
    elif veyon_role != 'master' and veyon_role != 'slave':
      print('unknown veyon role %s' % veyon_role, file=sys.stderr)
      sys.exit(1)

    menu = Gtk.Menu()
    role_label = Gtk.MenuItem(label='Veyon role: %s' % veyon_role)
    role_label.show()
    role_label.set_sensitive(False)
    menu.append(role_label)

    if veyon_role == 'master':
      VeyonMaster(menu)
    else:
      VeyonSlave(menu)

    menu.show_all()

    self.indicator.set_menu(menu)


  def main(self):
    Gtk.main()


applet = PuavoVeyonApplet()

if __name__ == '__main__':
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet.main()
