#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import dbus
import dbus.mainloop.glib
import gettext
import gi
import json
import netifaces
import random
import re
import signal
import socket
import string
import struct
import subprocess
import sys
import syslog
import time
import zeroconf

gi.require_version('AyatanaAppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AyatanaAppIndicator3
from gi.repository import GLib
from gi.repository import Gtk
from gi.repository import Notify

gettext.bindtextdomain('puavo-veyon-applet', '/usr/share/locale')
gettext.textdomain('puavo-veyon-applet')
_tr = gettext.gettext

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)


def logmsg(priority, message):
  print(message, file=sys.stderr)
  syslog.syslog(priority, message)


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


def read_firstline(pathname):
  with open(pathname) as file:
    return (file.readlines())[0].rstrip("\n")


# XXX is this needed?
class PuavoWidget:
  def connect_to_dbus(self, bus_name, service, interface):
    self.bus = dbus.SystemBus()
    dbusobj = self.bus.get_object(bus_name, service)
    return dbus.Interface(dbusobj, dbus_interface=interface)


  # XXX is this needed?
  def notify(self, summary, body=None):
    # no notifications if running on login screen
    if getpass.getuser() == 'Debian-gdm':
      return

    if body:
      Notify.Notification.new(summary, body).show()
    else:
      Notify.Notification.new(summary).show()


class Veyon():
  SERVICE_TYPE = '_http._tcp.local.'
  SERVICE_BASE = 'VeyonMaster._http._tcp.local.'
  SERVICE_PORT = 2991

  def receive_msg(socket):
    size = socket.recv(4)
    if len(size) != 4:
      raise Exception('no message size, connection closed')

    msgsize = struct.unpack('!i', size)[0]
    message_json = socket.recv(msgsize)
    if len(message_json) != msgsize:
      raise Exception('no message, connection closed')

    message = json.loads(message_json)

    if type(message) != dict:
      raise 'message is not a dict'
    if not 'type' in message:
      raise 'no type in message'
    if type(message['type']) != str:
      raise 'message type is not a string'

    return message


  def send_msg(socket, message):
    message = bytes(json.dumps(message), encoding='utf-8')
    msgsize = len(message)
    socket.send(struct.pack('!i', msgsize))
    socket.send(message)


class VeyonSlaveConnection(PuavoWidget):
  def __init__(self, master, slave_socket, slave_address):
    self.slave_socket = slave_socket
    self.address = slave_address
    self.hostname = None
    self.master = master
    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.slave_socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.incoming_slave_data,
                      self.slave_socket)


  def incoming_slave_data(self, io, cond, slave_socket):
    try:
      message = Veyon.receive_msg(slave_socket)

      if message['type'] == 'new_client':
        if not 'hostname' in message:
          raise 'no hostname in new_client message'
        if type(message['hostname']) != str:
          raise 'hostname is not a string'

        # XXX we would also like 'location' probably
        self.hostname = message['hostname']
        logmsg(syslog.LOG_INFO,
               'new slave %s at %s' % (self.hostname, self.address))

      elif message['type'] == 'public_key_request':
        if not 'pin' in message:
          raise 'public key request without a PIN'
        if type(message['pin']) != str:
          raise 'PIN is not a string'

        if message['pin'] == self.master.pin:
          logmsg(syslog.LOG_INFO,
                 'slave %s sent correct PIN' % self.hostname)
          self.send_public_key()
          self.master.update_config()
        else:
          logmsg(syslog.LOG_INFO,
                 'slave %s sent wrong PIN' % self.hostname)
          Veyon.send_msg(self.slave_socket, { 'type': 'wrong_pin' })
      else:
        # XXX should we define a protocol version
        # XXX and pass it on at some point?
        logmsg(syslog.LOG_INFO,
               'slave %s sent message %s that we do not understand' \
                 % (self.hostname, message['type']))

    except Exception as e:
      # XXX not everything here should be errors
      logmsg(syslog.LOG_ERR, 'error with slave %s: %s' % (self.address, e))
      self.master.remove_slave(self.address)
      return

    return True


  # XXX this should be useful but is not yet used in any situation
  def send_pin_request(self):
    logmsg(syslog.LOG_INFO, 'sending PIN request to %s' % self.hostname)
    Veyon.send_msg(self.slave_socket, { 'type': 'pin_request' })


  def send_public_key(self):
    logmsg(syslog.LOG_INFO, 'sending public key to %s' % self.hostname)
    msg = { 'type': 'public_key', 'public_key': self.master.public_key }
    Veyon.send_msg(self.slave_socket, msg)


  def disconnect_slave(self):
    logmsg(syslog.LOG_INFO,
           'disconnecting %s / %s' % (self.hostname, self.address))
    self.slave_socket.shutdown(socket.SHUT_RDWR)
    self.slave_socket.close()


class VeyonMaster(PuavoWidget):
  def __init__(self, menu):
    self.public_key = None
    self.update_config_call_pending = False
    self.veyon_slaves = {}

    self.host_ip_address = self.get_host_ip_address()

    self.pin_label = Gtk.MenuItem()
    self.create_new_pin()
    self.pin_label.show()
    self.pin_label.set_sensitive(False)
    menu.append(self.pin_label)

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/master',
                                           'org.puavo.Veyon.master')
    self.dbus_iface \
        .GetPublicKey(reply_handler=self.handle_get_public_key,
                      error_handler=self.handle_get_public_key_error)


  def get_host_ip_address(self):
    for intf in sorted(netifaces.interfaces()):
      if not re.match('^(eth|wlan)', intf):
        continue
      for ip_addr in netifaces.ifaddresses(intf)[netifaces.AF_INET]:
        if 'addr' in ip_addr:
          # pick the first IP address we got that is not localhost or tun*/vpn*
          # (if we would use several on the same host, that might get tricky)
          ip = ip_addr['addr']
          logmsg(syslog.LOG_INFO,
                 'using IP address %s on interface %s' % (ip, intf))
          return ip

    # XXX we should probably handle missing network connection a bit better?
    raise 'could not find IP address for this host'


  def set_pin(self, new_pin):
    self.pin = new_pin
    self.pin_label.set_label('PIN: %s' % new_pin)


  def create_new_pin(self):
    # We try to make a random PIN that is unique on a network with
    # maximum of 4096 hosts (netmask 255.255.240.0), on bigger networks
    # this might sometimes fail.
    random_number = random.randint(0, 23)
    split_ip = self.host_ip_address.split('.')
    ip_based_number = 256 * (int(split_ip[2]) % 16) + int(split_ip[3])
    nice_pin = '%05d' % (4096 * random_number + ip_based_number)
    self.set_pin(nice_pin)


  def handle_get_public_key(self, public_key):
    self.public_key = public_key
    self.setup_master_service()


  def handle_get_public_key_error(self, dbusexception):
    # XXX response handling?
    print('oh no public key dbus error: %s' % dbusexception)


  def setup_master_service(self):
    self.socket = socket.socket()
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.socket.bind((self.host_ip_address, Veyon.SERVICE_PORT))
    self.socket.listen()

    self.zeroconf = zeroconf.Zeroconf()

    host_ip_addresses = [
      socket.inet_pton(socket.AF_INET, self.host_ip_address)
    ]
    my_service_name = self.make_service_name()
    serviceinfo = zeroconf.ServiceInfo(Veyon.SERVICE_TYPE,
                                       my_service_name,
                                       addresses=host_ip_addresses,
                                       port=Veyon.SERVICE_PORT)
    self.zeroconf.register_service(serviceinfo)

    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.handle_new_slave,
                      self.socket)


  def make_service_name(self):
    hostname = read_firstline('/etc/puavo/hostname')
    time_seconds = str(int(time.time()))
    return (hostname + '_' + time_seconds + '.' + Veyon.SERVICE_BASE)


  def handle_new_slave(self, io, cond, sock):
    (conn, sock_slave_address) = sock.accept()
    slave_address = sock_slave_address[0]
    if slave_address in self.veyon_slaves:
      self.remove_slave(slave_address)
    slave = VeyonSlaveConnection(self, conn, slave_address)
    self.veyon_slaves[slave.address] = slave

    return True


  def update_config(self):
    self.update_config_hosts = []
    for slave in self.veyon_slaves.values():
      host = {
        'address':  slave.address,
        'hostname': slave.hostname,
        'location': 'Classroom',
      }
      self.update_config_hosts.append(host)

    if self.update_config_call_pending:
      return

    # UpdateConfig must not be called more than 10 times in a minute
    GLib.timeout_add_seconds(6, self.dbus_update_config)
    self.update_config_call_pending = True


  def dbus_update_config(self):
    self.update_config_call_pending = False
    self.dbus_iface \
        .UpdateConfig(json.dumps(self.update_config_hosts),
                      reply_handler=self.handle_update_config,
                      error_handler=self.handle_update_config_error)


  def handle_update_config(self):
    # XXX ?
    pass


  def handle_update_config_error(self, dbusexception):
    # XXX ?
    print('oh no update config dbus error: %s' % str(dbusexception))
    pass


  def remove_slave(self, address):
    logmsg(syslog.LOG_INFO, 'disconnecting %s' % address)
    self.veyon_slaves[address].disconnect_slave()
    del(self.veyon_slaves[address])



class VeyonMasterConnection():
  def __init__(self, address, port, slave):
    self.master_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.slave = slave

    self.address = address
    self.master_socket.connect((self.address, port))

    message = { 'type': 'new_client', 'hostname' : self.slave.hostname }
    Veyon.send_msg(self.master_socket, message)

    self.slave.pin_entry_button.set_sensitive(True)

    # XXX should this be asynchronous?
    GLib.io_add_watch(GLib.IOChannel(self.master_socket.fileno()),
                      0,
                      GLib.IOCondition.IN,
                      self.incoming_master_data,
                      self.master_socket)


  def incoming_master_data(self, io, cond, master_socket):
    try:
      message = Veyon.receive_msg(master_socket)

      if message['type'] == 'pin_request':
        self.slave.activate_pin_entry()

      elif message['type'] == 'public_key':
        if not 'public_key' in message:
          raise 'no public key in public_key message'
        if type(message['public_key']) != str:
          raise 'public_key is not a string'

        self.slave.set_veyon_public_key(message['public_key'])

      elif message['type'] == 'wrong_pin':
        # XXX error handling
        return

    except Exception as e:
      self.slave.remove_master(self.address)
      return

    return True


  def send_public_key_request(self, pin):
    msg = { 'type': 'public_key_request', 'pin': pin }
    Veyon.send_msg(self.master_socket, msg)


  def disconnect_master(self):
    self.master_socket.shutdown(socket.SHUT_RDWR)
    self.master_socket.close()


class VeyonSlave(PuavoWidget):
  def __init__(self, menu):
    self.zeroconf = zeroconf.Zeroconf()
    self.hostname = read_firstline('/etc/puavo/hostname')

    self.veyon_masters = {}

    self.dbus_iface = self.connect_to_dbus('org.puavo.Veyon',
                                           '/slave',
                                           'org.puavo.Veyon.slave')

    self.pin_entry_button = Gtk.MenuItem(label='Join a Veyon session')
    self.pin_entry_button.show()
    self.pin_entry_button.set_sensitive(False)
    self.pin_entry_button.connect('activate', self.activate_pin_entry)
    menu.append(self.pin_entry_button)

    self.pin_window = None

    service = self.zeroconf.get_service_info(Veyon.SERVICE_TYPE,
                                             Veyon.SERVICE_BASE)
    if service:
      self.add_masters(service)

    self.browser = zeroconf.ServiceBrowser(self.zeroconf,
                                           Veyon.SERVICE_TYPE,
                                           VeyonListenForMasters(self))


  def add_masters(self, service):
    for srv_address in service.addresses:
      address = str(socket.inet_ntop(socket.AF_INET, srv_address))
      if not address in self.veyon_masters:
        self.veyon_masters[address] \
          = VeyonMasterConnection(address, service.port, self)


  def remove_master(self, address):
    self.veyon_masters[address].disconnect_master()
    del(self.veyon_masters[address])
    # XXX if there are no masters, close pin window ?


  def activate_pin_entry(self, widget=None):
    if self.pin_window:
      self.pin_window.present()
      return

    self.label = Gtk.Label(label='Provide a PIN for Veyon session:')

    self.pin_entry = Gtk.Entry()
    self.pin_entry.set_input_purpose(Gtk.InputPurpose.DIGITS)
    self.pin_entry.set_max_length(5)
    self.pin_entry.set_width_chars(5)
    self.pin_entry.connect('changed', self.pin_entry_changed)

    self.box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
    self.box.pack_start(self.label, True, True, 3)
    self.box.pack_start(self.pin_entry, True, True, 3)

    self.alignment = Gtk.Alignment(xalign=0.5, yalign=0.5, xscale=0, yscale=0)
    self.alignment.add(self.box)

    self.pin_window = Gtk.Window()
    self.pin_window.connect('destroy', self.pin_window_closed)
    self.pin_window.set_opacity(0.5)
    self.pin_window.fullscreen()

    self.pin_window.add(self.alignment)
    self.pin_window.show_all()


  def pin_entry_changed(self, entry):
    entry.handler_block_by_func(self.pin_entry_changed)
    new_text = ''.join([c for c in entry.get_text() if c in string.digits])
    entry.set_text(new_text)
    entry.handler_unblock_by_func(self.pin_entry_changed)
    if len(new_text) == 5:
      # XXX we probably need some connect buttons and exit buttons instead
      # XXX of this, but this can be used for testing
      for master_connection in self.veyon_masters.values():
        master_connection.send_public_key_request(new_text)
      self.pin_window.destroy()


  def pin_window_closed(self, widget):
    self.pin_window = None


  def set_veyon_public_key(self, public_key):
    self.dbus_iface.AddPublicKey(public_key,
                                 reply_handler=self.handle_add_public_key,
                                 error_handler=self.handle_add_public_key_error)


  def handle_add_public_key(self):
    # XXX response handling?
    # XXX perhaps notification that communication has been established?
    pass


  def handle_add_public_key_error(self, dbusexception):
    # XXX response handling?
    print('oh no add public key dbus error: %s' % str(dbusexception))


class VeyonListenForMasters():
  def __init__(self, slave):
    self.slave = slave


  def add_service(self, zeroconf, service_type, name):
    name_base = '.'.join(name.split('.')[1:])
    if service_type == Veyon.SERVICE_TYPE \
      and name_base == Veyon.SERVICE_BASE:
        service = zeroconf.get_service_info(service_type, name)
        self.slave.add_masters(service)


class PuavoVeyonApplet:
  def __init__(self):
    # XXX the icon should be something else and maybe puavo-conf configurable?
    self.indicator \
      = AyatanaAppIndicator3.Indicator.new('puavo-veyon-applet',
          '/usr/share/icons/gnome/scalable/places/poi-school.svg',
          AyatanaAppIndicator3.IndicatorCategory.SYSTEM_SERVICES)

    self.indicator.set_status(AyatanaAppIndicator3.IndicatorStatus.ACTIVE)

    Notify.init('puavo-veyon-applet')

    try:
      veyon_role = puavoconf_get('puavo.veyon.role')
    except Exception as e:
      logmsg(syslog.LOG_ERR,
             'puavo.veyon.role could not be determined: %s' % e)
      sys.exit(1)

    if veyon_role == '':
      logmsg(syslog.LOG_NOTICE, 'no veyon role, exiting')
      sys.exit(0)
    elif veyon_role != 'master' and veyon_role != 'slave':
      logmsg(syslog.LOG_ERR, 'unknown veyon role: %s' % veyon_role)
      sys.exit(1)

    logmsg(syslog.LOG_NOTICE, 'operating in veyon %s role' % veyon_role)

    menu = Gtk.Menu()
    role_label = Gtk.MenuItem(label='Veyon role: %s' % veyon_role)
    role_label.show()
    role_label.set_sensitive(False)
    menu.append(role_label)

    if veyon_role == 'master':
      VeyonMaster(menu)
    else:
      VeyonSlave(menu)

    menu.show_all()

    self.indicator.set_menu(menu)


  def main(self):
    Gtk.main()


exitstatus = 0

syslog.openlog('puavo-veyon-applet')
logmsg(syslog.LOG_NOTICE, 'puavo-veyon-applet starting up')

try:
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet = PuavoVeyonApplet()
  applet.main()
except Exception as e:
  logmsg(syslog.LOG_ERR, 'unexpected error: %s' % e)
  exitstatus = 1

syslog.closelog()

sys.exit(exitstatus)
