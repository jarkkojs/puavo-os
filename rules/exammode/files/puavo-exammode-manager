#!/usr/bin/ruby

require 'dbus'
require 'gssapi'
require 'http'
require 'json'
require 'puavo/conf'
require 'syslog'
require 'uri'

# XXX dependencies: ruby-gssapi ruby-http
# XXX gssapi maybe through Gemfile?  (the deb package version has a bad bug)

# XXX this should probably use some non-root account

EXAMMODE_DIR = '/var/lib/puavo-exammode'
EXAMUSER_UID = 989
EXAMUSER_USERNAME = 'puavo-examuser'
SESSION_JSON_PATH = File.join(EXAMMODE_DIR, 'session.json')

SESSION_CONTROL_PATH = File.join("/run/user/#{ EXAMUSER_UID }",
                                 'exam-session-fifo')

VT_NUMBER = 42

puavoconf = Puavo::Conf.new
$examomatic_url = puavoconf.get('puavo.exammode.examomatic.url')
puavoconf.close

$puavo_domain = IO.read('/etc/puavo/domain').chomp

class ExamsListener
  def initialize(dbus, username, krb5ccname)
    @dbus = dbus
    @available_exams = nil
    @listener = Thread.new { connect_and_wait(username, krb5ccname) }
  end

  # XXX
  def fake_exams
    {
      'version' => '1.0',
      'exams' => [
        {
          'id'   => 123,
          'name' => 'An Exam On Puavo',
          'params' => {
            'url' => 'https://puavo.org',
          },
          'type' => 'single-window-webpage',
        }
      ]
    }
  end

  def destroy
    @listener.exit
  end

  def request_exams(username, krb5ccname)
    # XXX fake exams for now (we do not have a service yet for this)
    return fake_exams

    ENV['KRB5CCNAME'] = krb5ccname
    headers = { 'Host' => $puavo_domain }
    uri = URI($examomatic_url)
    http = HTTP.headers(headers)
    gsscli = GSSAPI::Simple.new(uri.host, 'HTTP')
    # XXX :delegate probably not needed with the examomatic
    token = gsscli.init_context(nil, :delegate => true)
    http = http.auth("Negotiate #{ Base64.strict_encode64(token) }")
    r = http.get(uri)
    JSON.parse(r.body.to_s)

    # XXX this should probably also check data validity
  end

  def get_exam_info_by_id(id)
    valid_exam_list = @available_exams['exams'].select { |e| e['id'] == id }
    raise 'could not find exam by id' unless valid_exam_list.count == 1
    valid_exam_list.first
  end

  def connect_and_wait(username, krb5ccname)
    Syslog.log(Syslog::LOG_NOTICE, 'connecting websocket to %s',
               $examomatic_url)
    # XXX should open a websocket to $exammomatic_url (instead of this)
    # XXX using username + krb5ccname and then receive current_exam from there
    loop do
      # XXX instead of sleep, we should react to messages received on websocket
      sleep 10
      begin
        current_exams = request_exams(username, krb5ccname)
      rescue StandardError => e
        Syslog.log(Syslog::LOG_ERR, 'error in requesting exams information: %s',
                   e.message)
        next
      end

      # XXX this comparison should make a deep comparison of hash
      if @available_exams != current_exams then
        @available_exams = current_exams
        @dbus.ExamsAvailable(current_exams.to_json)
      end
    end
  end
end

class PuavoExammode < DBus::Object
  def initialize(*args)
    @exams_listener = nil
    @locale = nil
    @registration_done = false
    super
  end

  def control_session(cmd)
    # XXX what if this fails?
    File.open(SESSION_CONTROL_PATH, 'w') do |ctrl_f|
      ctrl_f.puts(cmd)
    end
  end

  def write_exam_session_specs(exam_id)
    raise 'session locale missing, has the user registered yet?' \
      unless @locale && @registration_done

    exam_info = @exams_listener.get_exam_info_by_id(exam_id)

    session_data = {
      'locale' => @locale,
      'name'   => exam_info['name'],
      'params' => exam_info['params'],
      'type'   => exam_info['type'],
    }
    write_session_specs(session_data)
  end

  def write_prepare_session_specs()
    session_data = {
      'locale' => @locale,
      'type'   => 'prepare',
    }
    write_session_specs(session_data)
  end

  def write_session_specs(session_data)
    tmpfile = "#{ SESSION_JSON_PATH }.tmp"
    File.write(tmpfile, session_data.to_json)
    File.rename(tmpfile, SESSION_JSON_PATH)
  end

  def register(username, locale)
    @locale = locale
    @username = username
    @registration_done = true
    Syslog.log(Syslog::LOG_NOTICE, 'user %s (locale=%s) registered',
               username, locale)
  end

  # XXX unclear if this can be used or if this is useful
  # XXX puavo-exammode-applet could send Unregister message when it exits
  def unregister()
    unless @registration_done then
      Syslog.log(Syslog::LOG_INFO, 'unregister called but no one is registered')
      return
    end

    Syslog.log(Syslog::LOG_INFO, 'user %s (locale=%s) unregistered',
               @username, @locale)
    @locale = nil
    @registration_done = false
  end

  def get_vt_number
    begin
      desktop_session_vt = %x(fgconsole).chomp
      raise 'vt empty' if desktop_session_vt.empty?
    rescue StandardError => e
      errmsg = 'could not determine the current virtual console'
      Syslog.log(Syslog::LOG_ERR, errmsg)
      raise errmsg
    end

    return desktop_session_vt
  end

  dbus_interface 'org.puavo.Exam.exammode' do
    dbus_signal :ExamsAvailable, 'in exams:s'

    dbus_method :Register, 'in username:s, in locale:s, in krb5ccname:s' do
      |username, locale, krb5ccname|
        # XXX it should not be possible to do this in case there is an
        # XXX ongoing exam session
        register(username, locale)
        @exams_listener.destroy if @exams_listener
        @exams_listener = ExamsListener.new(self, username, krb5ccname)
        write_prepare_session_specs()
        control_session('prepare')
    end

    dbus_method :StartSession, 'in examid:i' do |exam_id|
      write_exam_session_specs(exam_id)

      if ! system('loginctl', 'lock-sessions') then
        Syslog.log(Syslog::LOG_ERR, 'could not lock desktop sessions')
        raise 'error in locking sessions'
      end

      if @desktop_session_vt then
        Syslog.log(Syslog::LOG_ERR,
          'tried to activate examination mode when it is already active')
        raise 'exammode session is already active'
      end

      @desktop_session_vt = get_vt_number()
      if ! system('/usr/bin/chvt', VT_NUMBER.to_s) then
        Syslog.log(Syslog::LOG_ERR,
                   'could not change virtual terminal to exam session')
        raise 'error in switch terminal at exammode session start'
      end
      control_session('start')
    end

    dbus_method :QuitSession do
      begin
        control_session('quit')

        begin
          File.unlink(SESSION_JSON_PATH)
        rescue Errno::ENOENT
        end

        Syslog.log(Syslog::LOG_INFO, 'examination mode ended')

        if ! system('chvt', @desktop_session_vt) then
          Syslog.log(Syslog::LOG_ERR, 'could not switch back to original vt')
          raise 'could not return back to the original vt'
        end
      ensure
        @desktop_session_vt = nil
      end
    end

    dbus_method :Unregister, '' do
      unregister()
    end
  end
end

Syslog.open(File.basename($0), Syslog::LOG_CONS)

begin
  bus = DBus::SystemBus.instance
  service = bus.request_service('org.puavo.Exam')
  service.export( PuavoExammode.new('/exammode') )

  mainloop = DBus::Main.new
  mainloop << bus
  mainloop.run
rescue StandardError => e
  Syslog.log(Syslog::LOG_ERR,
             'Error when running puavo-exammode-manager dbus service: %s',
             e.message)
end

Syslog.close()
