#!/usr/bin/ruby

require 'fileutils'
require 'json'
require 'puavo/conf'
require 'yaml'

CONTAINER_LIST = %w(postgres nextcloud collabora)
DOCKER_COMPOSE_TEMPLATE_PATH = '/etc/puavo-docker/docker-compose.yml.tmpl'
DOCKER_COMPOSE_PATH = '/etc/puavo-docker/docker-compose.yml'
DOCKER_FILES_DIR = '/etc/puavo-docker/files'
DOCKER_CONFIG_FILES_DIR = File.join(DOCKER_FILES_DIR, '.config')
SECRETS_DIR = '/etc/puavo-docker/secrets'

IMAGEMAP = {
  'collabora' => 'collabora/code',
  'nextcloud' => 'nextcloud',
  'postgres'  => 'postgres',
}

status = 0

def get_docker_ip()
  dockerd_conf = JSON.parse( IO.read('/etc/docker/daemon.json') )
  dockerd_conf['bip'].split('/').first
end

def ldap_agent_dn(ldap_base)
  "uid=nextcloud,ou=System Accounts,#{ ldap_base }"
end

FileUtils.mkdir_p(DOCKER_CONFIG_FILES_DIR)

PASSWORDS_TO_GENERATE = %w(postgres_db_password nextcloud_admin_password)
PASSWORDS_TO_GENERATE.each do |password_name|
  password_path = File.join(SECRETS_DIR, password_name)
  unless File.exists?(password_path) then
    chars = ("a".."z").to_a + ("A".."Z").to_a + ("0".."9").to_a
    password = Array.new(32) { chars[rand(chars.size)] }.join
    tmp_password_path = "#{ password_path }.tmp"
    File.write(tmp_password_path, "#{ password }\n", 0, :perm => 0600)
    File.rename(tmp_password_path, password_path)
  end
  File.chmod(0600, password_path)
end

begin
  ldap_base = File.read('/etc/puavo/ldap/base').chomp
rescue StandardError => e
  warn("could not determine system ldap base: #{ e.message }")
  exit(1)
end

puavo_ldap_password_path = File.join(SECRETS_DIR, 'puavo_ldap_password')
if not File.exists?(puavo_ldap_password_path) then
  warn(%Q[Will not install/setup Nextcloud,])
  warn(%Q["#{ puavo_ldap_password_path }" is missing.  You should write])
  warn(%Q[the password of "#{ ldap_agent_dn(ldap_base) }" to])
  warn(%Q["#{ puavo_ldap_password_path }".])
  exit(1)
end

File.chmod(0600, puavo_ldap_password_path)

puavoconf = Puavo::Conf.new

docker_compose = YAML::load_file(DOCKER_COMPOSE_TEMPLATE_PATH)

CONTAINER_LIST.each do |container_name|
  begin
    puavoconf_var = "puavo.docker.#{ container_name }.version"
    image_version = puavoconf.get(puavoconf_var)
    service_conf = docker_compose['services'][container_name]
    if service_conf['image'] then
      service_conf['image'] = "#{ IMAGEMAP[container_name] }:#{ image_version }"
    end
    if service_conf.dig('build', 'args', 'IMAGE') then
      service_conf['build']['args']['IMAGE'] \
        = "#{ IMAGEMAP[container_name] }:#{ image_version }"
    end
  rescue StandardError => e
    warn("could not set #{ container_name }: #{ e.message }")
    exit(1)
  end
end

begin
  puavo_hostname = File.read('/etc/puavo/hostname').chomp
  puavo_domain   = File.read('/etc/puavo/domain').chomp
  puavo_server_fqdn = "#{ puavo_hostname }.#{ puavo_domain }"
rescue StandardError => e
  warn("could not determine system ldap base: #{ e.message }")
  exit(1)
end

begin
  nextcloud_domain = puavoconf.get('puavo.docker.nextcloud.domain')
  raise 'no Nextcloud domain set' if nextcloud_domain.empty?
  nextcloud_env = docker_compose['services']['nextcloud']['environment']
  nextcloud_env['NEXTCLOUD_TRUSTED_DOMAINS'] = nextcloud_domain
  nextcloud_env['PUAVO_KERBEROS_REALM'] \
    = File.read('/etc/puavo/kerberos/realm').chomp
  nextcloud_env['PUAVO_LDAP_AGENT_DN'] = ldap_agent_dn(ldap_base)
  nextcloud_env['PUAVO_LDAP_BASE_DN'] = ldap_base
  nextcloud_env['PUAVO_SERVER_FQDN'] = puavo_server_fqdn
rescue StandardError => e
  warn("could not configure nextcloud for docker-compose: #{ e.message }")
  exit(1)
end

begin
  collabora_domain = puavoconf.get('puavo.docker.collabora.domain')
  raise 'no Collabora domain set' if collabora_domain.empty?
  collabora_env = docker_compose['services']['collabora']['environment'] || {}
  collabora_env['server_name'] = collabora_domain
  collabora_env['aliasgroup1'] = "https://#{ nextcloud_domain }"
  docker_compose['services']['collabora']['environment'] = collabora_env
rescue StandardError => e
  warn("could not configure collabora for docker-compose: #{ e.message }")
  exit(1)
end

collabora_enabled = false
office_domain_path = File.join(DOCKER_CONFIG_FILES_DIR, 'office_domain')
if puavoconf.get('puavo.docker.collabora.enabled') == 'true' \
  && !collabora_domain.empty? then
    tmp_office_domain_path = "#{ office_domain_path }.tmp"
    File.write(tmp_office_domain_path, "#{ collabora_domain }\n")
    File.rename(tmp_office_domain_path, office_domain_path)
else
  File.unlink(office_domain_path) rescue Errno::ENOENT
end

tmpfile = "#{ DOCKER_COMPOSE_PATH }.tmp"
File.write(tmpfile, docker_compose.to_yaml)
File.rename(tmpfile, DOCKER_COMPOSE_PATH)

FileUtils.copy_file('/etc/krb5.conf',
                    File.join(DOCKER_CONFIG_FILES_DIR, 'krb5.conf'),
                    :preserve => true)

begin
  nextcloud_keytab_path = File.join(SECRETS_DIR, 'nextcloud_keytab')
  unless File.exists?(nextcloud_keytab_path) then
    FileUtils.rm_f("#{ nextcloud_keytab_path }.tmp")
    system('kadmin.local', '-q',
           "ktadd -norandkey -k #{ nextcloud_keytab_path }.tmp HTTP/#{ nextcloud_domain }")
    File.rename("#{ nextcloud_keytab_path }.tmp", nextcloud_keytab_path)
  end
  FileUtils.chmod(0600, nextcloud_keytab_path)
rescue StandardError => e
  warn("could not write #{ nextcloud_keytab_path }: #{ e.message }")
  warn("perhaps HTTP/#{ nextcloud_domain } principal does not exist?")
  exit(1)
end

# setup dnsmasq configuration
begin
  docker_ip = get_docker_ip()
  dnsmasq_conf  = "host-record=#{ nextcloud_domain },#{ docker_ip }\n"
  dnsmasq_conf += "host-record=#{ collabora_domain },#{ docker_ip }\n"
  dnsmasq_conf_path = '/etc/dnsmasq.d/10-docker.conf'
  tmp_dnsmasq_conf_path = "#{ dnsmasq_conf_path }.tmp"
  File.write(tmp_dnsmasq_conf_path, dnsmasq_conf)

  if !File.exists?(dnsmasq_conf_path) \
    || !FileUtils.compare_file(dnsmasq_conf_path, tmp_dnsmasq_conf_path) then
      File.rename(tmp_dnsmasq_conf_path, dnsmasq_conf_path)
      system('service', 'dnsmasq', 'reload') \
        or raise('could not reload dnsmasq configuration')
  else
    File.unlink(tmp_dnsmasq_conf_path)
  end
rescue StandardError => e
  warn("could not configure dnsmasq: #{ e.message }")
  exit(1)
end

CONTAINER_LIST.each do |container_name|
  puavoconf_var = "puavo.docker.#{ container_name }.enabled"
  if puavoconf.get(puavoconf_var) == 'true' then
    puts("> starting up container #{ container_name }")
    unless system('docker-compose', '--file', DOCKER_COMPOSE_PATH,
                    '--project-name', 'puavo', 'up', '-d',
                    container_name) then
      warn("error in starting up #{ container_name }")
      status = 1
    end
    next
  end

  unless system('docker', 'inspect', container_name,
                          :out => File::NULL, :err => File::NULL) then
    # container does not exist, nothing to do
    next
  end

  puts("> removing container #{ container_name }")
  unless system('docker', 'container', 'stop', container_name,
                          :out => File::NULL, :err => File::NULL) then
    warn("error in stopping container #{ container_name }")
    status = 1
    next
  end

  unless system('docker', 'container', 'rm', container_name,
                          :out => File::NULL, :err => File::NULL) then
    warn("error in removing container #{ container_name }")
    status = 1
  end
end


puts('> removing unused Docker images')
unless system('docker', 'image', 'prune', '--force') then
  warn('error in pruning unused Docker images')
  status = 1
end

puavoconf.close()

exit(status)
